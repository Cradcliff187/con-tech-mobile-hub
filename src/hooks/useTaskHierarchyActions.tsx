
import { useState, useCallback } from 'react';
import { useTasks } from '@/hooks/useTasks';
import { useToast } from '@/hooks/use-toast';
import { Task } from '@/types/database';

interface UseTaskHierarchyActionsProps {
  projectId: string;
}

export const useTaskHierarchyActions = ({ projectId }: UseTaskHierarchyActionsProps) => {
  const [editingTask, setEditingTask] = useState<Task | null>(null);
  const [viewingTask, setViewingTask] = useState<Task | null>(null);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [isViewDialogOpen, setIsViewDialogOpen] = useState(false);
  
  const { tasks, updateTask, createTask } = useTasks();
  const { toast } = useToast();

  const handleEditTask = useCallback((taskId: string) => {
    const task = tasks.find(t => t.id === taskId);
    if (task) {
      setEditingTask(task);
      setIsEditDialogOpen(true);
    }
  }, [tasks]);

  const handleViewTask = useCallback((taskId: string) => {
    const task = tasks.find(t => t.id === taskId);
    if (task) {
      setViewingTask(task);
      setIsViewDialogOpen(true);
    }
  }, [tasks]);

  const handleDuplicateTask = useCallback(async (taskId: string) => {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;

    try {
      const duplicatedTask = {
        ...task,
        title: `${task.title} (Copy)`,
        status: 'not-started' as const,
        progress: 0,
        id: undefined, // Will be generated by database
        created_at: undefined,
        updated_at: undefined
      };

      const result = await createTask(duplicatedTask);
      if (result.error) {
        throw new Error(result.error);
      }

      toast({
        title: "Task Duplicated",
        description: `"${task.title}" has been duplicated successfully.`
      });
    } catch (error) {
      console.error('Error duplicating task:', error);
      toast({
        title: "Error",
        description: "Failed to duplicate task. Please try again.",
        variant: "destructive"
      });
    }
  }, [tasks, createTask, toast]);

  const handleDeleteTask = useCallback(async (taskId: string) => {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;

    const confirmDelete = window.confirm(
      `Are you sure you want to delete "${task.title}"? This action cannot be undone.`
    );

    if (!confirmDelete) return;

    try {
      // Note: We would need a deleteTask function in useTasks hook
      // For now, we'll update the status to indicate deletion
      const result = await updateTask(taskId, { 
        status: 'cancelled',
        updated_at: new Date().toISOString()
      });
      
      if (result.error) {
        throw new Error(result.error);
      }

      toast({
        title: "Task Deleted",
        description: `"${task.title}" has been deleted.`
      });
    } catch (error) {
      console.error('Error deleting task:', error);
      toast({
        title: "Error",
        description: "Failed to delete task. Please try again.",
        variant: "destructive"
      });
    }
  }, [tasks, updateTask, toast]);

  const closeEditDialog = useCallback(() => {
    setIsEditDialogOpen(false);
    setEditingTask(null);
  }, []);

  const closeViewDialog = useCallback(() => {
    setIsViewDialogOpen(false);
    setViewingTask(null);
  }, []);

  return {
    editingTask,
    viewingTask,
    isEditDialogOpen,
    isViewDialogOpen,
    handleEditTask,
    handleViewTask,
    handleDuplicateTask,
    handleDeleteTask,
    closeEditDialog,
    closeViewDialog
  };
};
